// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"
	time "time"

	lager "code.cloudfoundry.org/lager"
	atc "github.com/concourse/concourse/atc"
	db "github.com/concourse/concourse/atc/db"
	lock "github.com/concourse/concourse/atc/db/lock"
)

type FakeResourceConfig struct {
	AcquireResourceConfigCheckingLockWithIntervalCheckStub        func(lager.Logger, time.Duration, bool) (lock.Lock, bool, error)
	acquireResourceConfigCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
		arg3 bool
	}
	acquireResourceConfigCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	CheckErrorStub        func() error
	checkErrorMutex       sync.RWMutex
	checkErrorArgsForCall []struct {
	}
	checkErrorReturns struct {
		result1 error
	}
	checkErrorReturnsOnCall map[int]struct {
		result1 error
	}
	CreatedByBaseResourceTypeStub        func() *db.UsedBaseResourceType
	createdByBaseResourceTypeMutex       sync.RWMutex
	createdByBaseResourceTypeArgsForCall []struct {
	}
	createdByBaseResourceTypeReturns struct {
		result1 *db.UsedBaseResourceType
	}
	createdByBaseResourceTypeReturnsOnCall map[int]struct {
		result1 *db.UsedBaseResourceType
	}
	CreatedByResourceCacheStub        func() db.UsedResourceCache
	createdByResourceCacheMutex       sync.RWMutex
	createdByResourceCacheArgsForCall []struct {
	}
	createdByResourceCacheReturns struct {
		result1 db.UsedResourceCache
	}
	createdByResourceCacheReturnsOnCall map[int]struct {
		result1 db.UsedResourceCache
	}
	DefaultSpaceStub        func() atc.Space
	defaultSpaceMutex       sync.RWMutex
	defaultSpaceArgsForCall []struct {
	}
	defaultSpaceReturns struct {
		result1 atc.Space
	}
	defaultSpaceReturnsOnCall map[int]struct {
		result1 atc.Space
	}
	FindVersionStub        func(atc.Version) (db.ResourceConfigVersion, bool, error)
	findVersionMutex       sync.RWMutex
	findVersionArgsForCall []struct {
		arg1 atc.Version
	}
	findVersionReturns struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	findVersionReturnsOnCall map[int]struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	LatestVersionsStub        func() ([]db.ResourceConfigVersion, bool, error)
	latestVersionsMutex       sync.RWMutex
	latestVersionsArgsForCall []struct {
	}
	latestVersionsReturns struct {
		result1 []db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	latestVersionsReturnsOnCall map[int]struct {
		result1 []db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	OriginBaseResourceTypeStub        func() *db.UsedBaseResourceType
	originBaseResourceTypeMutex       sync.RWMutex
	originBaseResourceTypeArgsForCall []struct {
	}
	originBaseResourceTypeReturns struct {
		result1 *db.UsedBaseResourceType
	}
	originBaseResourceTypeReturnsOnCall map[int]struct {
		result1 *db.UsedBaseResourceType
	}
	SaveDefaultSpaceStub        func(atc.Space) error
	saveDefaultSpaceMutex       sync.RWMutex
	saveDefaultSpaceArgsForCall []struct {
		arg1 atc.Space
	}
	saveDefaultSpaceReturns struct {
		result1 error
	}
	saveDefaultSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceStub        func(atc.Space) error
	saveSpaceMutex       sync.RWMutex
	saveSpaceArgsForCall []struct {
		arg1 atc.Space
	}
	saveSpaceReturns struct {
		result1 error
	}
	saveSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceLatestVersionStub        func(atc.Space, atc.Version) error
	saveSpaceLatestVersionMutex       sync.RWMutex
	saveSpaceLatestVersionArgsForCall []struct {
		arg1 atc.Space
		arg2 atc.Version
	}
	saveSpaceLatestVersionReturns struct {
		result1 error
	}
	saveSpaceLatestVersionReturnsOnCall map[int]struct {
		result1 error
	}
	SaveUncheckedVersionStub        func(atc.Version, db.ResourceConfigMetadataFields) (bool, error)
	saveUncheckedVersionMutex       sync.RWMutex
	saveUncheckedVersionArgsForCall []struct {
		arg1 atc.Version
		arg2 db.ResourceConfigMetadataFields
	}
	saveUncheckedVersionReturns struct {
		result1 bool
		result2 error
	}
	saveUncheckedVersionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SaveVersionStub        func(atc.SpaceVersion) error
	saveVersionMutex       sync.RWMutex
	saveVersionArgsForCall []struct {
		arg1 atc.SpaceVersion
	}
	saveVersionReturns struct {
		result1 error
	}
	saveVersionReturnsOnCall map[int]struct {
		result1 error
	}
	SaveVersionsStub        func([]atc.Version) error
	saveVersionsMutex       sync.RWMutex
	saveVersionsArgsForCall []struct {
		arg1 []atc.Version
	}
	saveVersionsReturns struct {
		result1 error
	}
	saveVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	SetCheckErrorStub        func(error) error
	setCheckErrorMutex       sync.RWMutex
	setCheckErrorArgsForCall []struct {
		arg1 error
	}
	setCheckErrorReturns struct {
		result1 error
	}
	setCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceConfig) AcquireResourceConfigCheckingLockWithIntervalCheck(arg1 lager.Logger, arg2 time.Duration, arg3 bool) (lock.Lock, bool, error) {
	fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("AcquireResourceConfigCheckingLockWithIntervalCheck", []interface{}{arg1, arg2, arg3})
	fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceConfigCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceConfigCheckingLockWithIntervalCheckStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireResourceConfigCheckingLockWithIntervalCheckReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfig) AcquireResourceConfigCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakeResourceConfig) AcquireResourceConfigCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, time.Duration, bool) {
	fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RUnlock()
	argsForCall := fake.acquireResourceConfigCheckingLockWithIntervalCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceConfig) AcquireResourceConfigCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceConfigCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceConfigCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) AcquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceConfigCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceConfigCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) CheckError() error {
	fake.checkErrorMutex.Lock()
	ret, specificReturn := fake.checkErrorReturnsOnCall[len(fake.checkErrorArgsForCall)]
	fake.checkErrorArgsForCall = append(fake.checkErrorArgsForCall, struct {
	}{})
	fake.recordInvocation("CheckError", []interface{}{})
	fake.checkErrorMutex.Unlock()
	if fake.CheckErrorStub != nil {
		return fake.CheckErrorStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.checkErrorReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) CheckErrorCallCount() int {
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	return len(fake.checkErrorArgsForCall)
}

func (fake *FakeResourceConfig) CheckErrorReturns(result1 error) {
	fake.CheckErrorStub = nil
	fake.checkErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) CheckErrorReturnsOnCall(i int, result1 error) {
	fake.CheckErrorStub = nil
	if fake.checkErrorReturnsOnCall == nil {
		fake.checkErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) CreatedByBaseResourceType() *db.UsedBaseResourceType {
	fake.createdByBaseResourceTypeMutex.Lock()
	ret, specificReturn := fake.createdByBaseResourceTypeReturnsOnCall[len(fake.createdByBaseResourceTypeArgsForCall)]
	fake.createdByBaseResourceTypeArgsForCall = append(fake.createdByBaseResourceTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("CreatedByBaseResourceType", []interface{}{})
	fake.createdByBaseResourceTypeMutex.Unlock()
	if fake.CreatedByBaseResourceTypeStub != nil {
		return fake.CreatedByBaseResourceTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createdByBaseResourceTypeReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) CreatedByBaseResourceTypeCallCount() int {
	fake.createdByBaseResourceTypeMutex.RLock()
	defer fake.createdByBaseResourceTypeMutex.RUnlock()
	return len(fake.createdByBaseResourceTypeArgsForCall)
}

func (fake *FakeResourceConfig) CreatedByBaseResourceTypeReturns(result1 *db.UsedBaseResourceType) {
	fake.CreatedByBaseResourceTypeStub = nil
	fake.createdByBaseResourceTypeReturns = struct {
		result1 *db.UsedBaseResourceType
	}{result1}
}

func (fake *FakeResourceConfig) CreatedByBaseResourceTypeReturnsOnCall(i int, result1 *db.UsedBaseResourceType) {
	fake.CreatedByBaseResourceTypeStub = nil
	if fake.createdByBaseResourceTypeReturnsOnCall == nil {
		fake.createdByBaseResourceTypeReturnsOnCall = make(map[int]struct {
			result1 *db.UsedBaseResourceType
		})
	}
	fake.createdByBaseResourceTypeReturnsOnCall[i] = struct {
		result1 *db.UsedBaseResourceType
	}{result1}
}

func (fake *FakeResourceConfig) CreatedByResourceCache() db.UsedResourceCache {
	fake.createdByResourceCacheMutex.Lock()
	ret, specificReturn := fake.createdByResourceCacheReturnsOnCall[len(fake.createdByResourceCacheArgsForCall)]
	fake.createdByResourceCacheArgsForCall = append(fake.createdByResourceCacheArgsForCall, struct {
	}{})
	fake.recordInvocation("CreatedByResourceCache", []interface{}{})
	fake.createdByResourceCacheMutex.Unlock()
	if fake.CreatedByResourceCacheStub != nil {
		return fake.CreatedByResourceCacheStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createdByResourceCacheReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) CreatedByResourceCacheCallCount() int {
	fake.createdByResourceCacheMutex.RLock()
	defer fake.createdByResourceCacheMutex.RUnlock()
	return len(fake.createdByResourceCacheArgsForCall)
}

func (fake *FakeResourceConfig) CreatedByResourceCacheReturns(result1 db.UsedResourceCache) {
	fake.CreatedByResourceCacheStub = nil
	fake.createdByResourceCacheReturns = struct {
		result1 db.UsedResourceCache
	}{result1}
}

func (fake *FakeResourceConfig) CreatedByResourceCacheReturnsOnCall(i int, result1 db.UsedResourceCache) {
	fake.CreatedByResourceCacheStub = nil
	if fake.createdByResourceCacheReturnsOnCall == nil {
		fake.createdByResourceCacheReturnsOnCall = make(map[int]struct {
			result1 db.UsedResourceCache
		})
	}
	fake.createdByResourceCacheReturnsOnCall[i] = struct {
		result1 db.UsedResourceCache
	}{result1}
}

func (fake *FakeResourceConfig) DefaultSpace() atc.Space {
	fake.defaultSpaceMutex.Lock()
	ret, specificReturn := fake.defaultSpaceReturnsOnCall[len(fake.defaultSpaceArgsForCall)]
	fake.defaultSpaceArgsForCall = append(fake.defaultSpaceArgsForCall, struct {
	}{})
	fake.recordInvocation("DefaultSpace", []interface{}{})
	fake.defaultSpaceMutex.Unlock()
	if fake.DefaultSpaceStub != nil {
		return fake.DefaultSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.defaultSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) DefaultSpaceCallCount() int {
	fake.defaultSpaceMutex.RLock()
	defer fake.defaultSpaceMutex.RUnlock()
	return len(fake.defaultSpaceArgsForCall)
}

func (fake *FakeResourceConfig) DefaultSpaceReturns(result1 atc.Space) {
	fake.DefaultSpaceStub = nil
	fake.defaultSpaceReturns = struct {
		result1 atc.Space
	}{result1}
}

func (fake *FakeResourceConfig) DefaultSpaceReturnsOnCall(i int, result1 atc.Space) {
	fake.DefaultSpaceStub = nil
	if fake.defaultSpaceReturnsOnCall == nil {
		fake.defaultSpaceReturnsOnCall = make(map[int]struct {
			result1 atc.Space
		})
	}
	fake.defaultSpaceReturnsOnCall[i] = struct {
		result1 atc.Space
	}{result1}
}

func (fake *FakeResourceConfig) FindVersion(arg1 atc.Version) (db.ResourceConfigVersion, bool, error) {
	fake.findVersionMutex.Lock()
	ret, specificReturn := fake.findVersionReturnsOnCall[len(fake.findVersionArgsForCall)]
	fake.findVersionArgsForCall = append(fake.findVersionArgsForCall, struct {
		arg1 atc.Version
	}{arg1})
	fake.recordInvocation("FindVersion", []interface{}{arg1})
	fake.findVersionMutex.Unlock()
	if fake.FindVersionStub != nil {
		return fake.FindVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.findVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfig) FindVersionCallCount() int {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	return len(fake.findVersionArgsForCall)
}

func (fake *FakeResourceConfig) FindVersionArgsForCall(i int) atc.Version {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	argsForCall := fake.findVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) FindVersionReturns(result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.FindVersionStub = nil
	fake.findVersionReturns = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) FindVersionReturnsOnCall(i int, result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.FindVersionStub = nil
	if fake.findVersionReturnsOnCall == nil {
		fake.findVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigVersion
			result2 bool
			result3 error
		})
	}
	fake.findVersionReturnsOnCall[i] = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeResourceConfig) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfig) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfig) LatestVersions() ([]db.ResourceConfigVersion, bool, error) {
	fake.latestVersionsMutex.Lock()
	ret, specificReturn := fake.latestVersionsReturnsOnCall[len(fake.latestVersionsArgsForCall)]
	fake.latestVersionsArgsForCall = append(fake.latestVersionsArgsForCall, struct {
	}{})
	fake.recordInvocation("LatestVersions", []interface{}{})
	fake.latestVersionsMutex.Unlock()
	if fake.LatestVersionsStub != nil {
		return fake.LatestVersionsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.latestVersionsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfig) LatestVersionsCallCount() int {
	fake.latestVersionsMutex.RLock()
	defer fake.latestVersionsMutex.RUnlock()
	return len(fake.latestVersionsArgsForCall)
}

func (fake *FakeResourceConfig) LatestVersionsReturns(result1 []db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.LatestVersionsStub = nil
	fake.latestVersionsReturns = struct {
		result1 []db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) LatestVersionsReturnsOnCall(i int, result1 []db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.LatestVersionsStub = nil
	if fake.latestVersionsReturnsOnCall == nil {
		fake.latestVersionsReturnsOnCall = make(map[int]struct {
			result1 []db.ResourceConfigVersion
			result2 bool
			result3 error
		})
	}
	fake.latestVersionsReturnsOnCall[i] = struct {
		result1 []db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfig) OriginBaseResourceType() *db.UsedBaseResourceType {
	fake.originBaseResourceTypeMutex.Lock()
	ret, specificReturn := fake.originBaseResourceTypeReturnsOnCall[len(fake.originBaseResourceTypeArgsForCall)]
	fake.originBaseResourceTypeArgsForCall = append(fake.originBaseResourceTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("OriginBaseResourceType", []interface{}{})
	fake.originBaseResourceTypeMutex.Unlock()
	if fake.OriginBaseResourceTypeStub != nil {
		return fake.OriginBaseResourceTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.originBaseResourceTypeReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) OriginBaseResourceTypeCallCount() int {
	fake.originBaseResourceTypeMutex.RLock()
	defer fake.originBaseResourceTypeMutex.RUnlock()
	return len(fake.originBaseResourceTypeArgsForCall)
}

func (fake *FakeResourceConfig) OriginBaseResourceTypeReturns(result1 *db.UsedBaseResourceType) {
	fake.OriginBaseResourceTypeStub = nil
	fake.originBaseResourceTypeReturns = struct {
		result1 *db.UsedBaseResourceType
	}{result1}
}

func (fake *FakeResourceConfig) OriginBaseResourceTypeReturnsOnCall(i int, result1 *db.UsedBaseResourceType) {
	fake.OriginBaseResourceTypeStub = nil
	if fake.originBaseResourceTypeReturnsOnCall == nil {
		fake.originBaseResourceTypeReturnsOnCall = make(map[int]struct {
			result1 *db.UsedBaseResourceType
		})
	}
	fake.originBaseResourceTypeReturnsOnCall[i] = struct {
		result1 *db.UsedBaseResourceType
	}{result1}
}

func (fake *FakeResourceConfig) SaveDefaultSpace(arg1 atc.Space) error {
	fake.saveDefaultSpaceMutex.Lock()
	ret, specificReturn := fake.saveDefaultSpaceReturnsOnCall[len(fake.saveDefaultSpaceArgsForCall)]
	fake.saveDefaultSpaceArgsForCall = append(fake.saveDefaultSpaceArgsForCall, struct {
		arg1 atc.Space
	}{arg1})
	fake.recordInvocation("SaveDefaultSpace", []interface{}{arg1})
	fake.saveDefaultSpaceMutex.Unlock()
	if fake.SaveDefaultSpaceStub != nil {
		return fake.SaveDefaultSpaceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveDefaultSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SaveDefaultSpaceCallCount() int {
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	return len(fake.saveDefaultSpaceArgsForCall)
}

func (fake *FakeResourceConfig) SaveDefaultSpaceArgsForCall(i int) atc.Space {
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	argsForCall := fake.saveDefaultSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) SaveDefaultSpaceReturns(result1 error) {
	fake.SaveDefaultSpaceStub = nil
	fake.saveDefaultSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveDefaultSpaceReturnsOnCall(i int, result1 error) {
	fake.SaveDefaultSpaceStub = nil
	if fake.saveDefaultSpaceReturnsOnCall == nil {
		fake.saveDefaultSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveDefaultSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveSpace(arg1 atc.Space) error {
	fake.saveSpaceMutex.Lock()
	ret, specificReturn := fake.saveSpaceReturnsOnCall[len(fake.saveSpaceArgsForCall)]
	fake.saveSpaceArgsForCall = append(fake.saveSpaceArgsForCall, struct {
		arg1 atc.Space
	}{arg1})
	fake.recordInvocation("SaveSpace", []interface{}{arg1})
	fake.saveSpaceMutex.Unlock()
	if fake.SaveSpaceStub != nil {
		return fake.SaveSpaceStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveSpaceReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SaveSpaceCallCount() int {
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	return len(fake.saveSpaceArgsForCall)
}

func (fake *FakeResourceConfig) SaveSpaceArgsForCall(i int) atc.Space {
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	argsForCall := fake.saveSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) SaveSpaceReturns(result1 error) {
	fake.SaveSpaceStub = nil
	fake.saveSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveSpaceReturnsOnCall(i int, result1 error) {
	fake.SaveSpaceStub = nil
	if fake.saveSpaceReturnsOnCall == nil {
		fake.saveSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveSpaceLatestVersion(arg1 atc.Space, arg2 atc.Version) error {
	fake.saveSpaceLatestVersionMutex.Lock()
	ret, specificReturn := fake.saveSpaceLatestVersionReturnsOnCall[len(fake.saveSpaceLatestVersionArgsForCall)]
	fake.saveSpaceLatestVersionArgsForCall = append(fake.saveSpaceLatestVersionArgsForCall, struct {
		arg1 atc.Space
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("SaveSpaceLatestVersion", []interface{}{arg1, arg2})
	fake.saveSpaceLatestVersionMutex.Unlock()
	if fake.SaveSpaceLatestVersionStub != nil {
		return fake.SaveSpaceLatestVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveSpaceLatestVersionReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SaveSpaceLatestVersionCallCount() int {
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	return len(fake.saveSpaceLatestVersionArgsForCall)
}

func (fake *FakeResourceConfig) SaveSpaceLatestVersionArgsForCall(i int) (atc.Space, atc.Version) {
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	argsForCall := fake.saveSpaceLatestVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfig) SaveSpaceLatestVersionReturns(result1 error) {
	fake.SaveSpaceLatestVersionStub = nil
	fake.saveSpaceLatestVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveSpaceLatestVersionReturnsOnCall(i int, result1 error) {
	fake.SaveSpaceLatestVersionStub = nil
	if fake.saveSpaceLatestVersionReturnsOnCall == nil {
		fake.saveSpaceLatestVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceLatestVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveUncheckedVersion(arg1 atc.Version, arg2 db.ResourceConfigMetadataFields) (bool, error) {
	fake.saveUncheckedVersionMutex.Lock()
	ret, specificReturn := fake.saveUncheckedVersionReturnsOnCall[len(fake.saveUncheckedVersionArgsForCall)]
	fake.saveUncheckedVersionArgsForCall = append(fake.saveUncheckedVersionArgsForCall, struct {
		arg1 atc.Version
		arg2 db.ResourceConfigMetadataFields
	}{arg1, arg2})
	fake.recordInvocation("SaveUncheckedVersion", []interface{}{arg1, arg2})
	fake.saveUncheckedVersionMutex.Unlock()
	if fake.SaveUncheckedVersionStub != nil {
		return fake.SaveUncheckedVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.saveUncheckedVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfig) SaveUncheckedVersionCallCount() int {
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	return len(fake.saveUncheckedVersionArgsForCall)
}

func (fake *FakeResourceConfig) SaveUncheckedVersionArgsForCall(i int) (atc.Version, db.ResourceConfigMetadataFields) {
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	argsForCall := fake.saveUncheckedVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfig) SaveUncheckedVersionReturns(result1 bool, result2 error) {
	fake.SaveUncheckedVersionStub = nil
	fake.saveUncheckedVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfig) SaveUncheckedVersionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.SaveUncheckedVersionStub = nil
	if fake.saveUncheckedVersionReturnsOnCall == nil {
		fake.saveUncheckedVersionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.saveUncheckedVersionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfig) SaveVersion(arg1 atc.SpaceVersion) error {
	fake.saveVersionMutex.Lock()
	ret, specificReturn := fake.saveVersionReturnsOnCall[len(fake.saveVersionArgsForCall)]
	fake.saveVersionArgsForCall = append(fake.saveVersionArgsForCall, struct {
		arg1 atc.SpaceVersion
	}{arg1})
	fake.recordInvocation("SaveVersion", []interface{}{arg1})
	fake.saveVersionMutex.Unlock()
	if fake.SaveVersionStub != nil {
		return fake.SaveVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveVersionReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SaveVersionCallCount() int {
	fake.saveVersionMutex.RLock()
	defer fake.saveVersionMutex.RUnlock()
	return len(fake.saveVersionArgsForCall)
}

func (fake *FakeResourceConfig) SaveVersionArgsForCall(i int) atc.SpaceVersion {
	fake.saveVersionMutex.RLock()
	defer fake.saveVersionMutex.RUnlock()
	argsForCall := fake.saveVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) SaveVersionReturns(result1 error) {
	fake.SaveVersionStub = nil
	fake.saveVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveVersionReturnsOnCall(i int, result1 error) {
	fake.SaveVersionStub = nil
	if fake.saveVersionReturnsOnCall == nil {
		fake.saveVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveVersions(arg1 []atc.Version) error {
	var arg1Copy []atc.Version
	if arg1 != nil {
		arg1Copy = make([]atc.Version, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.saveVersionsMutex.Lock()
	ret, specificReturn := fake.saveVersionsReturnsOnCall[len(fake.saveVersionsArgsForCall)]
	fake.saveVersionsArgsForCall = append(fake.saveVersionsArgsForCall, struct {
		arg1 []atc.Version
	}{arg1Copy})
	fake.recordInvocation("SaveVersions", []interface{}{arg1Copy})
	fake.saveVersionsMutex.Unlock()
	if fake.SaveVersionsStub != nil {
		return fake.SaveVersionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveVersionsReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SaveVersionsCallCount() int {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	return len(fake.saveVersionsArgsForCall)
}

func (fake *FakeResourceConfig) SaveVersionsArgsForCall(i int) []atc.Version {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	argsForCall := fake.saveVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) SaveVersionsReturns(result1 error) {
	fake.SaveVersionsStub = nil
	fake.saveVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SaveVersionsReturnsOnCall(i int, result1 error) {
	fake.SaveVersionsStub = nil
	if fake.saveVersionsReturnsOnCall == nil {
		fake.saveVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SetCheckError(arg1 error) error {
	fake.setCheckErrorMutex.Lock()
	ret, specificReturn := fake.setCheckErrorReturnsOnCall[len(fake.setCheckErrorArgsForCall)]
	fake.setCheckErrorArgsForCall = append(fake.setCheckErrorArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("SetCheckError", []interface{}{arg1})
	fake.setCheckErrorMutex.Unlock()
	if fake.SetCheckErrorStub != nil {
		return fake.SetCheckErrorStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setCheckErrorReturns
	return fakeReturns.result1
}

func (fake *FakeResourceConfig) SetCheckErrorCallCount() int {
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	return len(fake.setCheckErrorArgsForCall)
}

func (fake *FakeResourceConfig) SetCheckErrorArgsForCall(i int) error {
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	argsForCall := fake.setCheckErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfig) SetCheckErrorReturns(result1 error) {
	fake.SetCheckErrorStub = nil
	fake.setCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) SetCheckErrorReturnsOnCall(i int, result1 error) {
	fake.SetCheckErrorStub = nil
	if fake.setCheckErrorReturnsOnCall == nil {
		fake.setCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceConfigCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.checkErrorMutex.RLock()
	defer fake.checkErrorMutex.RUnlock()
	fake.createdByBaseResourceTypeMutex.RLock()
	defer fake.createdByBaseResourceTypeMutex.RUnlock()
	fake.createdByResourceCacheMutex.RLock()
	defer fake.createdByResourceCacheMutex.RUnlock()
	fake.defaultSpaceMutex.RLock()
	defer fake.defaultSpaceMutex.RUnlock()
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.latestVersionsMutex.RLock()
	defer fake.latestVersionsMutex.RUnlock()
	fake.originBaseResourceTypeMutex.RLock()
	defer fake.originBaseResourceTypeMutex.RUnlock()
	fake.saveDefaultSpaceMutex.RLock()
	defer fake.saveDefaultSpaceMutex.RUnlock()
	fake.saveSpaceMutex.RLock()
	defer fake.saveSpaceMutex.RUnlock()
	fake.saveSpaceLatestVersionMutex.RLock()
	defer fake.saveSpaceLatestVersionMutex.RUnlock()
	fake.saveUncheckedVersionMutex.RLock()
	defer fake.saveUncheckedVersionMutex.RUnlock()
	fake.saveVersionMutex.RLock()
	defer fake.saveVersionMutex.RUnlock()
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	fake.setCheckErrorMutex.RLock()
	defer fake.setCheckErrorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ResourceConfig = new(FakeResourceConfig)
